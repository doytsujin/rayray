#include "extern/rayray.h"

// This is the core of raytracing, specialized by defining trace()
// It is used by both the preview kernel (which uses an scene encoded in
// a storage buffer) and the optimized kernel (which compiles the scene
// representation into GLSL).

layout(set=0, binding=0, std430) uniform Uniforms {
    rayUniforms u;
};
layout(set=0, binding=1) buffer Image {
    vec4[] image;
};

// Compute kernel dispatch size
layout(local_size_x=COMPUTE_SIZE) in;

#define SURFACE_EPSILON 1e-6
#define NORMAL_EPSILON  1e-8
#define PI 3.1415926538

#ifdef RAYRAY_SPECTRAL
#include "shaders/wavelength_rgb.h"
#define Color vec2
#define RAYRAY_GREEN Color(565, 1)
#else
#define Color vec3
#define RAYRAY_GREEN Color(0, 1, 0)
#endif

////////////////////////////////////////////////////////////////////////////////
// Forward declarations
bool trace(inout uint seed, inout vec3 pos, inout vec3 dir, inout Color color);

////////////////////////////////////////////////////////////////////////////////
// Jenkins hash function, specialized for a uint key
uint hash(uint key) {
    uint h = 0;
    for (int i=0; i < 4; ++i) {
        h += (key >> (i * 8)) & 0xFF;
        h += h << 10;
        h ^= h >> 6;
    }
    h += h << 3;
    h ^= h >> 11;
    h += h << 15;
    return h;
}


// Returns a pseudorandom value between -1 and 1
float rand(inout uint seed) {
    // 32-bit LCG Multiplier from
    // "Computationally Easy, Spectrally Good Multipliers for
    //  Congruential Pseudorandom Number Generators" [Steele + Vigna]
    seed = 0xadb4a92du * seed + 1;

    // Low bits have less randomness [Lâ€™ECUYER '99], so we'll shift the high
    // bits into the mantissa position of an IEEE float32, then mask with
    // the bit-pattern for 2.0
    uint m = (seed >> 9) | 0x40000000u;

    float f = uintBitsToFloat(m);   // Range [2:4]
    return f - 3.0;                 // Range [-1:1]
}

// Returns a coordinate uniformly distributed on a sphere's surface
vec3 rand3_on_sphere(inout uint seed) {
    float t = PI * rand(seed);
    float z = rand(seed);
    float r = sqrt((z + 1) * (1 - z));
    float x = cos(t) * r;
    float y = sin(t) * r;
    return vec3(x, y, z);
}

// Returns a coordinate uniformly distributed in a circle of radius 1
vec2 rand2_in_circle(inout uint seed) {
    float t = PI * rand(seed);
    float r = sqrt((rand(seed) + 1) / 2);
    return r * vec2(cos(t), sin(t));
}

// Normalize, snapping to the normal if the vector is pathologically short
vec3 sanitize_dir(vec3 dir, vec3 norm) {
    float len = dot(dir, dir);
    if (len >= NORMAL_EPSILON) {
        return dir / sqrt(len);
    } else {
        return norm;
    }
}


////////////////////////////////////////////////////////////////////////////////
float hit_plane(vec3 start, vec3 dir, vec3 norm, float off) {
    // dot(norm, pos) == off
    // dot(norm, start + n*dir) == off
    // dot(norm, start) + dot(norm, n*dir) == off
    // dot(norm, start) + n*dot(norm, dir) == off
    float d = (off - dot(norm, start)) / dot(norm, dir);
    return d;
}

float hit_finite_plane(vec3 start, vec3 dir, vec3 norm, float off,
                       vec3 q, vec4 bounds) {
    float d = hit_plane(start, dir, norm, off);
    if (d <= SURFACE_EPSILON) {
        return d;
    }
    vec3 p = start + d * dir; // Position on plane
    vec3 center = norm * off; // Center of plane, from which bounds are measured

    float dist_q = dot(p - center, q);
    if (dist_q < bounds.x || dist_q > bounds.y) {
        return -1;
    }
    vec3 r = cross(norm, q);
    float dist_r = dot(p - center, r);
    if (dist_r < bounds.z || dist_r > bounds.w) {
        return -1;
    }
    return d;
}

float hit_sphere(vec3 start, vec3 dir, vec3 center, float r) {
    vec3 delta = center - start;
    float d = dot(delta, dir);
    vec3 nearest = start + dir * d;
    float min_distance = length(center - nearest);
    if (min_distance < r) {
        // Return the smallest positive intersection, plus some margin so we
        // don't get stuck against the surface.  If we're inside the
        // sphere, then this will be against a negative normal
        float q = sqrt(r*r - min_distance*min_distance);
        if (d > q + SURFACE_EPSILON) {
            return d - q;
        } else {
            return d + q;
        }
    } else {
        return -1;
    }
}

vec3 norm_plane(vec3 norm) {
    return norm;
}

vec3 norm_sphere(vec3 pos, vec3 center) {
    return normalize(pos - center);
}

////////////////////////////////////////////////////////////////////////////////

bool mat_light(inout Color color, vec3 light_color) {
#ifdef RAYRAY_SPECTRAL
    vec3 rgb = WAVELENGTH_RGB[int(color.x)] * light_color;
    color.y *= dot(rgb, rgb); // Adjust brightness
#else
    color *= light_color;
#endif
    return true;
}

bool mat_diffuse(inout uint seed, inout Color color, inout vec3 dir,
                 vec3 norm, vec3 diffuse_color)
{
#ifdef RAYRAY_SPECTRAL
    vec3 rgb = WAVELENGTH_RGB[int(color.x)] * diffuse_color;
    color.y *= dot(rgb, rgb); // Adjust brightness
#else
    color *= diffuse_color;
#endif
    dir = sanitize_dir(norm + rand3_on_sphere(seed), norm);
    return false;
}

bool mat_metal(inout uint seed, inout Color color, inout vec3 dir,
               vec3 norm, vec3 metal_color, float fuzz)
{
#ifdef RAYRAY_SPECTRAL
    vec3 rgb = WAVELENGTH_RGB[int(color.x)] * metal_color;
    color.y *= dot(rgb, rgb); // Adjust brightness
#else
    color *= metal_color;
#endif
    dir -= norm * dot(norm, dir)*2;
    if (fuzz != 0) {
        dir += rand3_on_sphere(seed) * fuzz;
        if (fuzz >= 0.99) {
            dir = sanitize_dir(dir, norm);
        } else {
            dir = normalize(dir);
        }
    }
    return false;
}

// This doesn't support nested materials with different etas!
bool mat_glass(inout uint seed, inout Color color, inout vec3 dir,
               vec3 norm, float eta)
{
    // If we're entering the shape, then decide whether to reflect
    // or refract based on the incoming angle
    if (dot(dir, norm) < 0) {
        eta = 1/eta;

        // Use Schlick's approximation for reflectance.
        float cosine = min(dot(-dir, norm), 1.0);
        float r0 = (1 - eta) / (1 + eta);
        r0 = r0*r0;
        float reflectance = r0 + (1 - r0) * pow((1 - cosine), 5);

        // reflectance is [0-1], so bias rand() to match
        if (reflectance > (rand(seed) + 1)*0.5) {
            dir -= norm * dot(norm, dir)*2;
        } else {
            dir = refract(dir, norm, eta);
        }
    } else {
        // Otherwise, we're exiting the shape and need to check
        // for total internal reflection
        vec3 next_dir = refract(dir, -norm, eta);
        // If we can't refract, then reflect instead
        if (next_dir == vec3(0)) {
            dir -= norm * dot(norm, dir)*2;
        } else {
            dir = next_dir;
        }
    }
    return false;
}

////////////////////////////////////////////////////////////////////////////////

#define BOUNCES 6
void bounce(vec3 pos, vec3 dir, inout uint seed, inout Color color) {
    for (int i=0; i < BOUNCES; ++i) {
        // Walk to the next object in the scene, updating the system state
        // using a set of inout variables
        if (trace(seed, pos, dir, color)) {
            return;
        }
    }
    color = Color(0);
}

////////////////////////////////////////////////////////////////////////////////

void main() {
    uvec2 p = uvec2(gl_GlobalInvocationID.x % u.width_px,
                    gl_GlobalInvocationID.x / u.width_px);

    // Set up our random seed based on the frame and pixel position
    uint seed = hash(hash(u.samples) ^ hash(gl_GlobalInvocationID.x));
    vec4 fragColor = vec4(0);

    // This is the ray direction from the center of the camera,
    // without any bias due to perspective
    const vec3 camera_dir = normalize(u.camera.target - u.camera.pos);

    // Build an orthonormal frame for the camera
    const vec3 camera_dx = cross(camera_dir, u.camera.up);
    const vec3 camera_dy = -cross(camera_dir, camera_dx);
    const mat3 camera_mat = mat3(camera_dx, camera_dy, camera_dir);

    const vec2 camera_scale = vec2(float(u.width_px) / float(u.height_px), 1) * u.camera.scale;

    for (uint i=0; i < u.samples_per_frame; ++i) {
        // Add anti-aliasing by jittering within the pixel
        vec2 subpixel = vec2(rand(seed), rand(seed)) / 2;

        // Pixel position as a normalized [-1,1] value, with antialiasing
        vec2 pixel_xy = (p) / vec2(u.width_px, u.height_px) * 2 - 1;

        // Calculate the offset from camera center for this pixel, in 3D space,
        // then use this offset for both the start of the ray and for the
        // ray direction change due to perspective
        vec3 offset = camera_mat * vec3(camera_scale * pixel_xy, 0);
        vec3 start = u.camera.pos + offset;
        vec3 dir = normalize(camera_dir + u.camera.perspective * offset);

        // First, pick a target on the focal plane.
        // (This ends up with a curved focal plane, but that's fine)
        vec3 target = start + dir * u.camera.focal_distance;

        // Then, jitter the start position by the defocus amount
        vec2 defocus = u.camera.defocus * rand2_in_circle(seed);
        start += camera_mat * vec3(defocus, 0);

        // Finally, re-adjust the direction so that we hit the same target
        dir = normalize(target - start);

#ifdef RAYRAY_SPECTRAL
        // Pick a random wavelength between 400 and 700 nm
        Color color = vec2(rand(seed) * 150 + 550, 1);
#else
        // Start with white
        Color color = vec3(1);
#endif

        // Bounce the light around, updating the color based on what it hits
        bounce(start, dir, seed, color);

#ifdef RAYRAY_SPECTRAL
        fragColor += vec4(WAVELENGTH_RGB[int(color.x)] * color.y, 1);
#else
        fragColor += vec4(color, 1);
#endif
    }

    if (u.samples > 0) {
        image[gl_GlobalInvocationID.x] += fragColor;
    } else {
        image[gl_GlobalInvocationID.x] = fragColor;
    }
}
